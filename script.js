document.addEventListener("DOMContentLoaded", () => {
  
  

 
 
  

  // Apenas uma mensagem no console para confirmar que o projeto foi carregado
console.log("MAX Editor iniciado.");
mostrarNotificacaoAviso(`SEJA MUITO BEM VINDO(A) üòÅüé®`);

  
  // ==============================
// üîß Objeto global para armazenar o estado do editor
// ==============================
const MAXEditor = {
  camadaSelecionada: null,  // ‚Üê aqui vamos armazenar o ID da camada selecionada futuramente
  camadas: [],               // ‚Üê se quiser, tamb√©m pode usar para registrar todas as camadas
  interacaoObjetoAtiva: false, 
    zoom: 1,  
    panX: 0,   
    panY: 0    
};

   // --- VARI√ÅVEIS DE CONTROLE DO ZOOM/PAN DO CANVAS (MOVIDAS PARA C√Å) ---
    let isArrastando = false; // Controla o arrasto do canvas com um dedo/mouse
    let ultimoXCanvas = 0; // √öltima posi√ß√£o X para c√°lculo de pan do canvas
    let ultimoYCanvas = 0; // √öltima posi√ß√£o Y para c√°lculo de pan do canvas

    let distanciaInicialTouch = null; // Dist√¢ncia entre dois dedos para zoom de pin√ßa
    let escalaInicialTouch = 1; // Escala inicial para zoom de pin√ßa
  
  
// =============================
//     ABRIR MODAL "CRIAR"
// =============================

// Pega o bot√£o e o modal
const botaoCriar = document.getElementById("btn-criar");
const modalCriar = document.getElementById("modal-criar");

// Ao clicar no bot√£o, remove a classe "oculto" e mostra o modal
botaoCriar.addEventListener("click", () => {
  // üßº Restaura os valores padr√£o
  document.getElementById("nome").value = "Meu Projeto";
  document.getElementById("largura").value = 1080;
  document.getElementById("altura").value = 1080;

  // üëÅÔ∏è Mostra o modal
  modalCriar.classList.remove("oculto");
});

// =============================
//     FECHAR MODAL (X)
// =============================
const botaoFechar = document.getElementById("fechar-modal");

botaoFechar.addEventListener("click", () => {
  modalCriar.classList.add("oculto"); // Esconde o modal novamente
});

// =======================================
//       CRIAR PROJETO E MOSTRAR EDITOR
// =======================================

const botaoCriarProjeto = document.getElementById("confirmar-criacao");
const telaInicial = document.getElementById("tela-inicial");
const telaEditor = document.getElementById("tela-editor");
const canvasContainer = document.getElementById("canvas-container");

botaoCriarProjeto.addEventListener("click", () => {
  // üü¢ Captura os valores digitados
  const nome = document.getElementById("nome").value.trim();
  const largura = parseInt(document.getElementById("largura").value);
  const altura = parseInt(document.getElementById("altura").value);

  // =========================
  // üîí VALIDA√á√ïES INICIAIS
  // =========================

  // üö´ Nome n√£o pode estar vazio
  if (!nome) {
    mostrarNotificacao("Digite um nome para o projeto.");
    return;
  }

  // üö´ Largura e altura precisam estar entre 100 e 5000
  if (
    isNaN(largura) || isNaN(altura) ||
    largura < 100 || largura > 5000 ||
    altura < 100 || altura > 5000
  ) {
    mostrarNotificacao("Largura e altura devem ser entre 100 e 5000 pixels.");
    return;
  }

  // üîí Oculta o modal e a tela inicial
  modalCriar.classList.add("oculto");
  telaInicial.classList.add("oculto");

  // üëÅÔ∏è Exibe a tela de edi√ß√£o
  telaEditor.classList.remove("oculto");
  
  // üîÅ Garante que o menu lateral e o painel de camadas estejam fechados
menuLateral.classList.add("oculto");
menuLateral.classList.remove("ativo");

painelCamadas.classList.add("oculto");
painelCamadas.classList.remove("ativo");


// üßº Limpa qualquer conte√∫do anterior da √°rea de edi√ß√£o
canvasContainer.innerHTML = "";

// üìê Define dinamicamente o tamanho da √°rea de edi√ß√£o (div canvas-container)
canvasContainer.style.width = largura + "px";
canvasContainer.style.height = altura + "px";

// üß© Aplica o fundo quadriculado visual
canvasContainer.style.backgroundColor = "#ffffff";
canvasContainer.style.backgroundImage = `
  linear-gradient(45deg, #eee 25%, transparent 25%),
  linear-gradient(-45deg, #eee 25%, transparent 25%),
  linear-gradient(45deg, transparent 75%, #eee 75%),
  linear-gradient(-45deg, transparent 75%, #eee 75%)
`;
canvasContainer.style.backgroundSize = "20px 20px";
canvasContainer.style.backgroundPosition = "0 0, 0 10px, 10px -10px, -10px 0px";
canvasContainer.style.border = "1px solid #4caf50";

	// üîÅ Recria o contorno de sele√ß√£o
	const contorno = document.createElement("div");
	contorno.id = "contorno-selecao";
	contorno.className = "contorno-objeto oculto";
	contorno.innerHTML = `
	  <div class="handle-tl"></div>
	  <div class="handle-tr"></div>
	  <div class="handle-bl"></div>
	  <div class="handle-br"></div>
	  <div class="handle-rot"></div>
	`;
	canvasContainer.appendChild(contorno);


  // üß† Voc√™ pode salvar as infos do projeto aqui se quiser usar depois
  console.log(`Projeto "${nome}" criado com ${largura}x${altura}px`);
  
  // üßº Limpa as camadas antigas da lista lateral
document.querySelectorAll(".item-camada").forEach(camada => camada.remove());

// üßº Volta para o Container principal dos botoes de ferramentas
mostrarContainer("principal");

// üßº remove um fundo escuro do menu
document.getElementById("fundo-escuro-menu").classList.remove("ativo");
document.getElementById("fundo-escuro-menu").classList.add("oculto");

setTimeout(() => {
  centralizarCanvasComZoom();
}, 100); // espera 100ms para o DOM renderizar o canvas corretamente


});
  
  
  
// =======================================================================
// üîç SISTEMA DE ZOOM + MOVIMENTA√á√ÉO (PC e CELULAR)
// -----------------------------------------------------------------------
// Permite:
// - Zoom suave com scroll do mouse e gesto de pin√ßa
// - Movimento suave da tela com mouse ou dedo (liberado apenas com zoom > 1)
// - Centraliza√ß√£o autom√°tica baseada no tamanho da tela
// - Prote√ß√£o contra sumi√ßo do canvas
// =======================================================================




function iniciarSistemaDeZoom() {
    const wrapper = document.getElementById("canvas-wrapper");
    const transformado = document.getElementById("canvas-transformado");
    const canvas = document.getElementById("canvas-container");

    if (!wrapper || !canvas || !transformado) return;

    // Vari√°veis de controle LOCAL para a fun√ß√£o iniciarSistemaDeZoom
    // Elas controlam o estado de arrasto e √∫ltimas posi√ß√µes do mouse/touch para o PAN do CANVAS.
    let isArrastando = false; 
    let ultimoXCanvas = 0; 
    let ultimoYCanvas = 0; 

    // Vari√°veis para o zoom de pin√ßa (gesto de dois dedos no touch)
    let distanciaInicialTouch = null; 
    let escalaInicialTouch = 1; 

    const ZOOM_MIN = 0.1;
    const ZOOM_MAX = 10;

    // Fun√ß√£o que aplica a transforma√ß√£o visual (translate e scale) ao elemento 'canvas-transformado'
    // Agora usa as propriedades de MAXEditor
    function atualizarTransformacao() {
        transformado.style.transform = `translate(calc(-50% + ${MAXEditor.panX}px), calc(-50% + ${MAXEditor.panY}px)) scale(${MAXEditor.zoom})`;
        transformado.style.transformOrigin = "center center";
        transformado.style.transition = "transform 0.08s ease-out";
        verificarSeCanvasSumiu();
    }

    // Centraliza o canvas na tela e ajusta o zoom para que ele caiba completamente
    function centralizarCanvasComZoom() {
        const larguraWrapper = wrapper.clientWidth;
        const alturaWrapper = wrapper.clientHeight;
        const larguraCanvas = canvas.offsetWidth;
        const alturaCanvas = canvas.offsetHeight;

        const margem = 0.9; // Uma pequena margem para o canvas n√£o "grudar" nas bordas
        const escalaIdeal = Math.min(larguraWrapper / larguraCanvas, alturaWrapper / canvas.offsetHeight) * margem;

        // Atualiza as propriedades de zoom e pan no objeto global MAXEditor
        MAXEditor.zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, escalaIdeal));
        MAXEditor.panX = 0;
        MAXEditor.panY = 0;

        atualizarTransformacao();
    }

    // Reseta o zoom e a posi√ß√£o do canvas para o estado padr√£o (zoom 1x, centralizado)
    function recentralizarCanvas() {
        MAXEditor.zoom = 1;
        MAXEditor.panX = 0;
        MAXEditor.panY = 0;
        atualizarTransformacao();
    }

    // Vari√°vel para controlar o tempo da √∫ltima centraliza√ß√£o autom√°tica
    let ultimaCentralizacao = 0;

    // Verifica se o canvas est√° muito fora da √°rea vis√≠vel e o recentraliza automaticamente
    function verificarSeCanvasSumiu() {
        if (!canvas || canvas.offsetWidth === 0 || canvas.offsetHeight === 0) return;

        const agora = Date.now();
        const intervaloMinimo = 500; // Intervalo m√≠nimo de 500ms entre centraliza√ß√µes

        if (agora - ultimaCentralizacao < intervaloMinimo) return;

        const margem = 60; // Margem em pixels para considerar o canvas "fora da tela"
        const wrapperBox = wrapper.getBoundingClientRect();
        const canvasBox = canvas.getBoundingClientRect();

        const foraHorizontal =
            canvasBox.right < wrapperBox.left + margem ||
            canvasBox.left > wrapperBox.right - margem;

        const foraVertical =
            canvasBox.bottom < wrapperBox.top + margem ||
            canvasBox.top > wrapperBox.bottom - margem;

        if (foraHorizontal || foraVertical) {
            console.warn("‚ö†Ô∏è Canvas fora da √°rea vis√≠vel. Recentralizando...");
            ultimaCentralizacao = agora;
            centralizarCanvasComZoom();
        }
    }

    // Exp√µe globalmente as fun√ß√µes para que possam ser chamadas de outras partes do c√≥digo
    window.centralizarCanvasComZoom = centralizarCanvasComZoom;
    window.recentralizarCanvas = recentralizarCanvas;

    // ======================================
    // EVENTOS DE MOUSE / SCROLL (PC)
    // ======================================

    // Zoom com a roda do mouse (scroll)
    wrapper.addEventListener("wheel", (e) => {
        if (e.ctrlKey || e.metaKey) return; // Ignora se Ctrl/Cmd est√° pressionado (para zoom nativo do navegador)
        e.preventDefault(); // Previne o scroll padr√£o da p√°gina

        const delta = e.deltaY > 0 ? -0.1 : 0.1; // Determina a dire√ß√£o do zoom
        MAXEditor.zoom += delta; // Ajusta o zoom do MAXEditor
        MAXEditor.zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, MAXEditor.zoom)); // Limita o zoom entre min e max
        atualizarTransformacao();
    }, { passive: false }); // 'passive: false' √© necess√°rio para permitir e.preventDefault()

    // In√≠cio do arrasto do canvas com o mouse (mousedown)
    wrapper.addEventListener("mousedown", (e) => {
        const contorno = document.getElementById("contorno-selecao");
        
        // Verifica 1: H√° uma camada selecionada E o clique foi dentro da "margem de seguran√ßa" expandida do contorno?
        let isWithinSafeMargin = false;
        if (MAXEditor.camadaSelecionada && contorno && !contorno.classList.contains("oculto")) {
            const contornoRect = contorno.getBoundingClientRect();
            const margemSeguranca = 30; // Define o "raio" da zona de seguran√ßa (em pixels)

            // Calcula as coordenadas da √°rea expandida
            const expandedLeft = contornoRect.left - margemSeguranca;
            const expandedTop = contornoRect.top - margemSeguranca;
            const expandedRight = contornoRect.right + margemSeguranca;
            const expandedBottom = contornoRect.bottom + margemSeguranca;

            // Se o clique ocorreu dentro dessa √°rea expandida, a flag √© ativada
            if (e.clientX >= expandedLeft && e.clientX <= expandedRight &&
                e.clientY >= expandedTop && e.clientY <= expandedBottom) {
                isWithinSafeMargin = true;
            }
        }

        // Se o clique foi no pr√≥prio objeto (para arrastar o objeto) OU dentro da margem de seguran√ßa do contorno,
        // N√ÉO INICIE O ARRASTO DO CANVAS. Deixe o evento seguir para o ObjetoInteracaoManager.
        if (e.target.closest(".objeto-edicao") || isWithinSafeMargin) { // <--- CORRE√á√ÉO AQUI
            return; 
        }

        // Se nenhuma das condi√ß√µes acima for atendida, ent√£o √© um clique v√°lido para arrastar o canvas.
        isArrastando = true; // Ativa a flag de arrasto do canvas
        ultimoXCanvas = e.clientX; // Armazena a posi√ß√£o X inicial do mouse
        ultimoYCanvas = e.clientY; // Armazena a posi√ß√£o Y inicial do mouse
        transformado.style.transition = "none"; // Desativa transi√ß√£o CSS para um movimento mais direto
    });

    // Movimento do mouse (mousemove) para arrastar o canvas
    document.addEventListener("mousemove", (e) => {
        // Se uma intera√ß√£o de objeto (arrastar/redimensionar/rotacionar) estiver ativa,
        // o arrasto do canvas √© desativado imediatamente para evitar conflitos.
        if (MAXEditor.interacaoObjetoAtiva) {
            isArrastando = false; // Garante que a flag de arrasto do canvas seja desativada
            return;
        }

        if (!isArrastando) return; // Se a flag de arrasto do canvas n√£o estiver ativa, n√£o fa√ßa nada

        const dx = e.clientX - ultimoXCanvas; // Calcula a mudan√ßa na posi√ß√£o X do mouse
        const dy = e.clientY - ultimoYCanvas; // Calcula a mudan√ßa na posi√ß√£o Y do mouse
        
        // Atualiza as propriedades de pan (posi√ß√£o) do MAXEditor
        MAXEditor.panX += dx;
        MAXEditor.panY += dy;
        
        ultimoXCanvas = e.clientX; // Atualiza a √∫ltima posi√ß√£o do mouse para o pr√≥ximo c√°lculo
        ultimoYCanvas = e.clientY;

        atualizarTransformacao(); // Aplica a nova transforma√ß√£o visual ao canvas
    });

    // Fim do arrasto do canvas (mouseup)
    document.addEventListener("mouseup", () => {
        isArrastando = false; // Desativa a flag de arrasto do canvas
    });

    // ======================================
    // EVENTOS DE TOQUE (MOBILE)
    // ======================================

    // In√≠cio do toque (touchstart) - Usado para identificar zoom de pin√ßa ou ignorar toques de um dedo.
    wrapper.addEventListener("touchstart", (e) => {
        // A l√≥gica de prioridade para touch (margem de seguran√ßa e clique direto no objeto)
        // √© similar √† do mouse, mas a forma como os eventos touch s√£o propagados √© diferente.
        // O ObjetoInteracaoManager j√° lida com a captura do evento de um dedo no objeto/handle.
        // Aqui, focamos no gesto de pin√ßa (dois dedos) para zoom/pan do canvas.
        if (e.touches.length === 2) { 
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            distanciaInicialTouch = Math.hypot(dx, dy); // Calcula a dist√¢ncia inicial entre os dedos

            escalaInicialTouch = MAXEditor.zoom; // Armazena o zoom atual do MAXEditor como base para o zoom de pin√ßa

            // Posi√ß√£o m√©dia dos dois dedos para o c√°lculo inicial do pan (movimento)
            ultimoXCanvas = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            ultimoYCanvas = (e.touches[0].clientY + e.touches[1].clientY) / 2;

        } else if (e.touches.length === 1) { 
            // N√£o inicia o pan no wrapper com um dedo. Essa intera√ß√£o √© gerenciada pelo ObjetoInteracaoManager (para arrastar objetos).
            // Nenhuma a√ß√£o aqui para um dedo no wrapper, o que permite que o ObjetoInteracaoManager capture.
        }
    }, { passive: false }); // 'passive: false' √© crucial para permitir e.preventDefault()

    // Movimento do toque (touchmove) - Para zoom de pin√ßa e pan com dois dedos
    wrapper.addEventListener("touchmove", (e) => {
        // Se houver dois dedos e a dist√¢ncia inicial foi capturada (indicando um gesto de pin√ßa)
        if (e.touches.length === 2 && distanciaInicialTouch !== null) {
            const [t1, t2] = e.touches;

            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            const novaDistancia = Math.hypot(dx, dy); // Calcula a nova dist√¢ncia entre os dedos

            const novoMeio = { // Calcula o novo ponto m√©dio dos dedos
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };

            const fatorZoom = novaDistancia / distanciaInicialTouch; // Calcula o fator de escala do zoom
            // Atualiza o zoom do MAXEditor, garantindo que fique dentro dos limites
            MAXEditor.zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, escalaInicialTouch * fatorZoom));

            const dxMeio = novoMeio.x - ultimoXCanvas; // Calcula o deslocamento do pan
            const dyMeio = novoMeio.y - ultimoYCanvas; // Calcula o deslocamento do pan
            
            // Atualiza as propriedades de pan do MAXEditor
            MAXEditor.panX += dxMeio;
            MAXEditor.panY += dyMeio;

            ultimoXCanvas = novoMeio.x; // Atualiza a √∫ltima posi√ß√£o m√©dia para o pr√≥ximo c√°lculo
            ultimoYCanvas = novoMeio.y;

            atualizarTransformacao(); // Aplica a nova transforma√ß√£o visual
            e.preventDefault(); // Previne a rolagem padr√£o da p√°gina, essencial para gestos de toque
        }
    }, { passive: false }); // 'passive: false' permite preventDefault()

    // Fim do toque (touchend) - Reseta a vari√°vel de dist√¢ncia inicial do touch
    wrapper.addEventListener("touchend", () => {
        distanciaInicialTouch = null;
    });

    // Inicia o canvas centralizado e com zoom adequado ao carregar o sistema
    centralizarCanvasComZoom();
}






  // =============================
//     MENU LATERAL ABRIR/FECHAR
// =============================
const botaoMenu = document.getElementById("btn-menu");
const menuLateral = document.getElementById("menu-lateral");
const fecharMenu = document.getElementById("fechar-menu");

// Abrir o menu lateral
botaoMenu.addEventListener("click", () => {
  menuLateral.classList.remove("oculto"); // torna vis√≠vel
  menuLateral.classList.add("ativo");     // aplica transi√ß√£o para a esquerda
  
  document.getElementById("fundo-escuro-menu").classList.remove("oculto");
  document.getElementById("fundo-escuro-menu").classList.add("ativo");document.getElementById("fundo-escuro-menu").classList.remove("oculto");
  document.getElementById("fundo-escuro-menu").classList.add("ativo");

});


// Fechar o menu lateral
fecharMenu.addEventListener("click", () => {
  menuLateral.classList.remove("ativo");  // inicia sa√≠da com anima√ß√£o


  document.getElementById("fundo-escuro-menu").classList.remove("ativo");
  document.getElementById("fundo-escuro-menu").classList.add("oculto");
  
  // Espera a anima√ß√£o acabar antes de esconder completamente
  setTimeout(() => {
    menuLateral.classList.add("oculto");
  }, 300); // 300ms = tempo da transi√ß√£o definida no CSS
});

  // =============================
//     VOLTAR √Ä TELA INICIAL
// =============================
const botaoVoltar = document.getElementById("btn-voltar");

botaoVoltar.addEventListener("click", () => {
  // Fecha menu lateral
  menuLateral.classList.remove("ativo");
  setTimeout(() => {
    menuLateral.classList.add("oculto");
  }, 300);

  // Esconde tela de edi√ß√£o e mostra a inicial
  telaEditor.classList.add("oculto");
  telaInicial.classList.remove("oculto");

  // Limpa o canvas
  canvasContainer.innerHTML = '';

  console.log("Voltando para a tela inicial.");
});
  
  
  
 // ========================================
// ‚ö†Ô∏è Fun√ß√£o para mostrar notifica√ß√£o animada
// ========================================
function mostrarNotificacao(mensagem) {
  const notificacao = document.getElementById("notificacao-erro");
  if (!notificacao) return; // seguran√ßa extra

  notificacao.textContent = mensagem;
  notificacao.classList.add("ativa");

  setTimeout(() => {
    notificacao.classList.remove("ativa");
  }, 3000); // desaparece ap√≥s 3 segundos
}
  
  // ========================================
// ‚ö†Ô∏è NOTIFICA√á√ÉO DE AVISO
// ========================================
  function mostrarNotificacaoAviso(mensagem) {
  const aviso = document.getElementById("notificacao-aviso");
  if (!aviso) return;

  aviso.textContent = mensagem;
  aviso.classList.add("ativa");

  setTimeout(() => {
    aviso.classList.remove("ativa");
  }, 3000); // ‚è≥ some ap√≥s 3 segundos
}



    
  
  
  
  
  // =============================
//   (   C  A  M  A  D  A  S   )
// =============================
  
  
  
  
  
  
  
  
  // ==========================
// üé® √çcones SVG offline
// ==========================
  
  // olho / cadeado / arrastar
  
const svgOlhoAberto = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.478 0-8.268-2.943-9.542-7z" /></svg>`;

const svgOlhoFechado = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.542-7a10.05 10.05 0 012.379-3.939M6.43 6.43A9.969 9.969 0 0112 5c4.478 0 8.268 2.943 9.542 7a9.969 9.969 0 01-1.507 2.709M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3l18 18" /></svg>`;

const svgCadeadoAberto = `
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
    d="M7 10V6a5 5 0 019.9-1" />
  <rect x="4" y="10" width="16" height="10" rx="2" ry="2" stroke-width="2" stroke="currentColor" fill="none"/>
  <path d="M12 14v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>
`;

  const svgCadeadoFechado = `
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
    d="M12 17a1.5 1.5 0 001.5-1.5V14a1.5 1.5 0 00-3 0v1.5A1.5 1.5 0 0012 17z" />
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
    d="M16 8V6a4 4 0 10-8 0v2m-2 0h12a2 2 0 012 2v8a2 2 0 01-2 2H6a2 2 0 01-2-2v-8a2 2 0 012-2z" />
</svg>
`;




  
  
  

  // =============================
//    ABRIR / FECHAR CAMADAS
// =============================
const botaoCamadas = document.getElementById("abrir-camadas");
const painelCamadas = document.getElementById("painel-camadas");

botaoCamadas.addEventListener("click", () => {
  if (painelCamadas.classList.contains("ativo")) {
    painelCamadas.classList.remove("ativo");
    painelCamadas.classList.add("oculto");
  } else {
    painelCamadas.classList.remove("oculto");
    painelCamadas.classList.add("ativo");
  }
});
  
  // =============================
//   FECHAR ABA DE CAMADAS (√ó)
// =============================
const botaoFecharCamadas = document.getElementById("fechar-camadas");

botaoFecharCamadas.addEventListener("click", () => {
  painelCamadas.classList.remove("ativo");
  painelCamadas.classList.add("oculto");
});
  
  
  
  
  
  
// ==============================
// üéØ SISTEMA DE BOT√ïES INFERIORES PARA CRIAR CAMADAS (MODULARIZADO SEM QUEBRAR NADA)
// ==============================

  
  
 
  // FUN√á√ÉO DE CONTAINERS DOS BOT√îES
  
  function mostrarContainer(tipo) {
  // Oculta todos os grupos
  document.querySelectorAll('.grupo-botoes').forEach(container => {
    container.classList.add("oculto");
  });

  // Mostra apenas o container correspondente
  const containerAtivo = document.getElementById(`container-${tipo}`);
  if (containerAtivo) {
    containerAtivo.classList.remove("oculto");
  }
}

  
  
  
  
  
  
  
  
// üëâ Modal e campos para camada de texto
const modalTexto = document.getElementById("modal-texto");
const inputTexto = document.getElementById("input-texto");
const btnConfirmarTexto = document.getElementById("btn-confirmar-texto");
const btnCancelarTexto = document.getElementById("btn-cancelar-texto");

// üëâ Modal de imagem j√° est√° no HTML via input invis√≠vel
const inputImagem = document.getElementById("input-imagem");

// ==============================
// üí° Lista modular das ferramentas dispon√≠veis
// Cada ferramenta tem:
// - nome identificador (ex: 'texto')
// - fun√ß√£o a executar quando clicado
// ==============================

const ferramentasDisponiveis = {
  texto: () => {
    // Abre o modal de texto
    modalTexto.classList.remove("oculto");
    inputTexto.value = "";
    inputTexto.focus();
  },

  imagem: () => {
    // Define o que acontece quando a imagem for selecionada
    inputImagem.onchange = (event) => {
      const arquivo = event.target.files[0];
      if (!arquivo) return;

      const leitor = new FileReader();
      leitor.onload = () => {
        const imagemBase64 = leitor.result;

        // Cria a nova camada de imagem (usando fun√ß√£o que j√° existe)
        criarCamadaBase("imagem", arquivo.name, imagemBase64);
        

        // Limpa o campo para permitir selecionar o mesmo arquivo novamente
        inputImagem.value = "";
      };
      leitor.readAsDataURL(arquivo); // Converte a imagem para base64
    };

    // Abre o seletor de arquivos
    inputImagem.click();
  },

  forma: () => {
    // Cria uma nova camada de forma com nome padr√£o
    criarCamadaBase("forma", "Forma");
    
  }
};

// ==============================
// üß† Detecta qual bot√£o foi clicado e executa a ferramenta correta
// ==============================

document.querySelectorAll(".botao-ferramenta").forEach(botao => {
  botao.addEventListener("click", () => {
    const textoBotao = botao.textContent.toLowerCase();

    // Verifica qual ferramenta foi clicada com base no texto
    if (textoBotao.includes("texto")) {
      ferramentasDisponiveis.texto();
    } else if (textoBotao.includes("imagem")) {
      ferramentasDisponiveis.imagem();
    } else if (textoBotao.includes("forma")) {
      ferramentasDisponiveis.forma();
    }
  });
});

// ==============================
// ‚ùå BOT√ÉO "Cancelar" no modal de texto
// ==============================
btnCancelarTexto.addEventListener("click", () => {
  modalTexto.classList.add("oculto");
});

// ==============================
// ‚úÖ BOT√ÉO "Confirmar" para adicionar o texto
// ==============================
btnConfirmarTexto.addEventListener("click", () => {
  const texto = inputTexto.value.trim();
  if (texto === "") return;

  // Cria a camada de texto com o valor digitado
  criarCamadaBase("texto", texto);
  modalTexto.classList.add("oculto");
});

// ==============================
// üñ±Ô∏è Clique fora do modal de texto fecha a caixa
// ==============================
modalTexto.addEventListener("click", (e) => {
  if (e.target === modalTexto) {
    modalTexto.classList.add("oculto");
  }
});
    


  



  
// ==========================
// üß† NOVO SISTEMA DE CAMADAS
// ==========================

// Refer√™ncia √† lista onde as camadas ser√£o exibidas
const listaCamadas = document.getElementById("lista-camadas");

// ============================================
// üß± Fun√ß√£o principal para criar uma nova camada na lista lateral
// ============================================
function criarCamadaBase(tipo, nome, imagemBase64 = null) {
  // üîß Cria um novo elemento <div> representando uma camada
  const camada = document.createElement("div");
  camada.className = "item-camada"; // Aplica classe CSS padr√£o

  // üÜî Gera um ID √∫nico baseado no timestamp atual
  const idUnico = `camada-${Date.now()}`;
  camada.dataset.id = idUnico;

  
  
  
// =========================================
// üñºÔ∏è MINIATURA DA CAMADA
// =========================================
// Por padr√£o, a miniatura √© um quadrado cinza
// ‚ö†Ô∏è Monta a miniatura com base no tipo
let miniaturaHTML = '<div class="miniatura-camada"></div>';

if (tipo === "imagem" && imagemBase64) {
  // Se for imagem, exibe como fundo da miniatura
  miniaturaHTML = `<div class="miniatura-camada" style="background-image: url('${imagemBase64}')"></div>`;
  // salva a foto da camada para duplicar
    camada.dataset.imagemBase64 = imagemBase64;

} 
else if (tipo === "texto") {
 // üîß Exibe o texto real como preview
  const conteudoTexto = imagemBase64 || nome; // üëà Usa o conte√∫do se vier da duplica√ß√£o
  miniaturaHTML = `<div class="miniatura-camada miniatura-texto">
    <span class="preview-texto">${conteudoTexto}</span>
  </div>`;
}
else if (tipo === "forma") {
  // Se for forma, exibe um quadrado colorido como exemplo
  miniaturaHTML = `<div class="miniatura-camada miniatura-forma">
    <div class="forma-exemplo"></div>
  </div>`;
}


  
  


  
  // üîÅ Define r√≥tulo(titulo do tipo de cada camada) bonito com base no tipo
  
let rotuloTipo = "";
switch (tipo) {
  case "texto":
    rotuloTipo = "Camada de Texto";
    break;
  case "imagem":
    rotuloTipo = "Camada de Imagem";
    break;
  case "forma":
    rotuloTipo = "Camada Geom√©trica";
    break;
  default:
    rotuloTipo = "‚ùì Camada";
}
  
  
  // =========================================
  // üß© Estrutura interna da camada
  // =========================================
  camada.innerHTML = `
<div class="tipo-camada-topo">${rotuloTipo}</div> <!-- Tipo da camada no topo -->

  <span class="icone icone-opcoes">‚ãÆ</span> <!-- Menu de op√ß√µes -->

<!-- üñºÔ∏è Miniatura -->
  ${miniaturaHTML} <!-- Miniatura (imagem ou vazia) -->

 <!-- üëÅÔ∏è Visibilidade -->
  <span class="icone-camada icone-visivel" title="Alternar visibilidade">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.478 0-8.268-2.943-9.542-7z" /></svg>
  </span>
  
   <!-- üîí Bloqueio -->
  <span class="icone-camada icone-bloqueio" title="Bloquear edi√ß√£o">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
    d="M7 10V6a5 5 0 019.9-1" />
  <rect x="4" y="10" width="16" height="10" rx="2" ry="2" stroke-width="2" stroke="currentColor" fill="none"/>
  <path d="M12 14v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>
  </span>

 <!-- üìù Nome da camada -->
  <div class="nome-camada" title="${nome}">${nome}</div> <!-- Nome com at√© 2 linhas -->

  <!-- ‚†ø √çcone de arrastar -->
  <span class="icone-camada icone-arrastar" title="Arrastar camada">
    <svg viewBox="0 0 24 24"><path fill="white" d="M4 9h16v2H4V9zm0 4h16v2H4v-2z"/></svg>
  </span>
`;
  
  
// üîç Captura o bot√£o de op√ß√µes (‚ãÆ)
const btnOpcoes = camada.querySelector(".icone-opcoes");

// ‚¨áÔ∏è Mostra o menu flutuante ao lado do bot√£o ‚ãÆ
// Dentro da fun√ß√£o criarCamadaBase, onde btnOpcoes j√° existe
btnOpcoes.addEventListener("click", (e) => {
  e.stopPropagation(); // Impede o clique de fechar o menu automaticamente

  // Remove qualquer menu j√° existente
  const menuExistente = document.querySelector(".menu-opcoes");
  if (menuExistente) menuExistente.remove();

  // Cria o menu flutuante
  const menu = document.createElement("div");
  menu.className = "menu-opcoes";
  menu.innerHTML = `
    <button class="opcao-menu btn-duplicar">Duplicar camada</button>
    <button class="opcao-menu btn-renomear">Renomear camada</button>
    <button class="opcao-menu btn-apagar"> Apagar camada</button>
  `;

  // Posiciona o menu ao lado do bot√£o ‚ãÆ
  // Adiciona o menu ao body
document.body.appendChild(menu);

// Captura a posi√ß√£o do bot√£o ‚ãÆ
const rect = btnOpcoes.getBoundingClientRect();
const menuWidth = menu.offsetWidth;
const menuHeight = menu.offsetHeight;

// Posi√ß√£o inicial (√† direita do bot√£o)
let left = rect.right + 5;
let top = rect.top;

// üß± AJUSTE HORIZONTAL: Se ultrapassar a largura da tela, posiciona para a esquerda
if (left + menuWidth > window.innerWidth) {
  left = rect.left - menuWidth - 5; // Vai para a esquerda do bot√£o
  if (left < 5) left = 5; // Garante que n√£o saia da tela
}

// üß± AJUSTE VERTICAL: Se ultrapassar a altura da tela, sobe o menu
if (top + menuHeight > window.innerHeight) {
  top = window.innerHeight - menuHeight - 10; // Sobe um pouco
  if (top < 5) top = 5;
}

// üß© Aplica a posi√ß√£o final
menu.style.left = `${left}px`;
menu.style.top = `${top}px`;

  // üéØ ATIVA OS BOT√ïES AP√ìS INSERIR NO DOM
  const btnDuplicar = menu.querySelector(".btn-duplicar");
  const btnRenomear = menu.querySelector(".btn-renomear");
  const btnApagar = menu.querySelector(".btn-apagar");

  // ‚úÖ Fun√ß√£o Duplicar
  btnDuplicar.addEventListener("click", () => {
    menu.remove();
    console.log("Duplicar camada:", camada.dataset.id);
     duplicarCamada(camada);
  menu.style.display = "none"; // Fecha o menu flutuante ap√≥s duplicar
  });

  // ‚úÖ Fun√ß√£o Renomear
  btnRenomear.addEventListener("click", () => {
    menu.remove();
    console.log("Renomear camada:", camada.dataset.id);
    menu.remove(); // Fecha o menu flutuante

  // Captura o elemento do nome da camada
  const nomeElemento = camada.querySelector(".nome-camada");
  const nomeAtual = nomeElemento.textContent;

  // Abre um prompt para digitar o novo nome
  const novoNome = prompt("Digite o novo nome da camada:", nomeAtual);

  // Se o nome for v√°lido, atualiza na interface
  if (novoNome && novoNome.trim() !== "") {
    const textoFinal = novoNome.trim();
    nomeElemento.textContent = textoFinal.length > 20 ? textoFinal.slice(0, 20) + "..." : textoFinal;
    nomeElemento.title = textoFinal; // Atualiza o title tamb√©m
    mostrarNotificacaoAviso(`‚úÖ Camada renomeada`);
  }
  });

  // ‚úÖ Fun√ß√£o Apagar
btnApagar.addEventListener("click", () => {
  menu.remove(); // Fecha o menu

  // üîî Mostra a confirma√ß√£o do sistema
  const confirmacao = confirm("Tem certeza que deseja remover esta camada?");

  if (confirmacao) {
    console.log("Apagar camada:", camada.dataset.id);
    camada.remove(); // Remove a camada da lista
    mostrarNotificacaoAviso(`‚úÖ Camada removida`);
  } else {
    console.log("Remo√ß√£o cancelada.");
    mostrarNotificacaoAviso(`‚ùå Remo√ß√£o cancelada`);
  }
});

});
  
  
  // Fecha o menu se clicar fora dele
document.addEventListener("click", () => {
  const antigo = document.querySelector(".menu-opcoes");
  if (antigo) antigo.remove();
});



  
 // ============================================
// üìÑ DUPLICAR CAMADA COM NOME NUMERADO E MINIATURA
// ============================================
function duplicarCamada(camadaOriginal) {
  // üè∑Ô∏è Pega o nome completo da camada original (usado como base para o novo nome)
  const nomeOriginal = camadaOriginal.querySelector(".nome-camada").getAttribute("title") || "Camada";

  // üß± Tipo da camada (texto, imagem, forma...)
  const tipo = camadaOriginal.dataset.tipo;

  // üî§ Remove qualquer sufixo de "(c√≥pia)" do nome original
  const baseNome = nomeOriginal.replace(/\s*\(c√≥pia(?:\s\d+)?\)$/, "");

  // üì¶ Coleta todos os nomes de camadas existentes
  const nomesExistentes = [...document.querySelectorAll(".nome-camada")].map(el =>
    el.getAttribute("title")
  );

  // üîç Filtra os nomes que t√™m a mesma base e j√° s√£o c√≥pias
  const indices = nomesExistentes
    .filter(n => n && n.startsWith(baseNome))
    .map(n => {
      const match = n.match(/\(c√≥pia(?:\s(\d+))?\)$/);
      return match ? parseInt(match[1] || 1) : 0;
    });

  // üî¢ Calcula o √≠ndice da nova c√≥pia
  const novoIndice = indices.length > 0 ? Math.max(...indices) + 1 : 1;

  // üìù Define o novo nome com sufixo adequado
  const novoNome = novoIndice === 1 ? `${baseNome} (c√≥pia)` : `${baseNome} (c√≥pia ${novoIndice})`;

  // üñºÔ∏è Verifica se h√° imagemBase64 (salva no dataset na cria√ß√£o)
  const imagemBase64 = camadaOriginal.dataset.imagemBase64 || null;

    // üìù Se for camada de texto, pega o conte√∫do do texto da miniatura
  let conteudoTexto = null;
  if (tipo === "texto") {
    const textoSpan = camadaOriginal.querySelector(".preview-texto");
    if (textoSpan) {
      conteudoTexto = textoSpan.textContent;
    }
  }

  // ‚úÖ Cria a nova camada com tudo (tipo, nome e conte√∫do)
  criarCamadaBase(tipo, novoNome, imagemBase64 || conteudoTexto); // Aproveita o mesmo terceiro par√¢metro
  
  mostrarNotificacaoAviso(`‚úÖ Camada de ${tipo} duplicada!`);
  
  criarObjetoCanvas(camada); // novaCamada √© o objeto que voc√™ acabou de criar

  
  
  
  
}




  // ‚ûï Adiciona a camada rec√©m-criada dentro da lista lateral - cria a cima das outra camadas
  listaCamadas.insertBefore(camada, listaCamadas.firstChild);
  
  
  // üñºÔ∏è Cria o objeto correspondente na √°rea de edi√ß√£o
const objCriado = criarObjetoCanvas({
  id: idUnico,
  tipo: tipo,
  nome: nome,
  dados: {
    imagemBase64: imagemBase64
  }
});
  

// Verifica se o objeto foi criado com sucesso antes de aplicar o contorno e iniciar arrasto
    if (objCriado) {
        aplicarContornoEdicao(objCriado);
    console.log("‚úÖ Contorno aplicado no objeto:", objCriado);
    ObjetoInteracaoManager.ativar(objCriado); // <-- ATUALIZE ESTA LINHA
    console.log("‚úÖ Intera√ß√£o habilitada para o objeto:", objCriado);
    } else {
        console.warn("‚ö†Ô∏è Objeto n√£o foi criado, contorno e intera√ß√£o n√£o aplicados");
    }
	
	
	
	
	
//===============================
// seleciona a camada do obj criado
//===============================
  
  // üîÑ Remove sele√ß√£o anterior
document.querySelectorAll(".item-camada").forEach(c => c.classList.remove("ativa"));

    camada.classList.add("ativa"); // Aplica destaque nesta
    
    // muda o container dos bot√µes ferramentas
    const tipoSelecionado = camada.dataset.tipo;
mostrarContainer(tipo);
    
    // ‚úÖ Mostra o bot√£o flutuante de "voltar" √† esquerda
document.getElementById("btn-desselecionar").classList.remove("oculto");
    
    MAXEditor.camadaSelecionada = camada.dataset.id;

  
  
  

  // üì¶ Armazena propriedades √∫teis no pr√≥prio elemento
  camada.dataset.tipo = tipo;
  camada.dataset.visivel = "true";
  camada.dataset.bloqueado = "false";

  // =========================================
  // üëÅÔ∏è Evento de clique no olho (visibilidade)
  // =========================================
const btnOlho = camada.querySelector(".icone-visivel");
btnOlho.addEventListener("click", () => {
  const visivel = camada.dataset.visivel === "true";
  camada.dataset.visivel = (!visivel).toString();

  // Troca o SVG conforme o estado
  btnOlho.innerHTML = visivel ? svgOlhoFechado : svgOlhoAberto;
});

  // =========================================
  // üîí Evento de clique no cadeado (bloqueio)
  // =========================================
const btnCadeado = camada.querySelector(".icone-bloqueio");
btnCadeado.addEventListener("click", () => {
  const bloqueado = camada.dataset.bloqueado === "true";
  camada.dataset.bloqueado = (!bloqueado).toString();

  // Troca o SVG conforme o estado
  btnCadeado.innerHTML = bloqueado ? svgCadeadoFechado : svgCadeadoAberto;
});

  // =========================================
  // ‚ú® Selecionar camada ativa ao clicar nela
  // =========================================
  camada.addEventListener("click", () => {
    // Remove classe ativa de todas
    document.querySelectorAll(".item-camada").forEach(c => c.classList.remove("ativa"));
    camada.classList.add("ativa"); // Aplica destaque nesta
    
    // muda o container dos bot√µes ferramentas
    const tipoSelecionado = camada.dataset.tipo;
mostrarContainer(tipoSelecionado);
    
    // ‚úÖ Mostra o bot√£o flutuante de "voltar" √† esquerda
document.getElementById("btn-desselecionar").classList.remove("oculto");
    
    MAXEditor.camadaSelecionada = camada.dataset.id;

  

	// aplicar o contorno no objeto correspondente a camada selecionanda
  aplicarContornoEdicao(objCriado);
  console.log("‚úÖ Contorno aplicado no objeto:", objCriado);

 // Obtenha o objeto do canvas correspondente a esta camada selecionada
        const objetoDoCanvas = document.querySelector(`.objeto-edicao[data-id="${camada.dataset.id}"]`);
        
        if (objetoDoCanvas) {
            aplicarContornoEdicao(objetoDoCanvas);
            console.log("‚úÖ Contorno aplicado no objeto:", objetoDoCanvas);
            ObjetoInteracaoManager.ativar(objetoDoCanvas); // <-- ATUALIZE ESTA LINHA
            console.log("‚úÖ Intera√ß√£o habilitada para o objeto:", objetoDoCanvas);
        } else {
            console.warn("‚ö†Ô∏è Objeto do canvas n√£o encontrado para a camada selecionada.");
        }

  
  });
  
  
  
 // ================================================
// ‚ùå FUN√á√ÉO PARA REMOVER A SELE√á√ÉO DA CAMADA ATIVA
// E VOLTAR A MOSTRAR O CONTAINER PRINCIPAL
// ================================================
function limparSelecaoDeCamadas() {
  // üîÅ Remove destaque de todas as camadas na aba lateral
  document.querySelectorAll(".item-camada").forEach(c => c.classList.remove("ativa"));

  // ‚ùå Remove ID salvo da camada selecionada
  MAXEditor.camadaSelecionada = null;

  // üéØ Volta a exibir o container de bot√µes principal (texto, imagem, forma...)
  mostrarContainer("principal");
  
  ObjetoInteracaoManager.desativar(); // <-- ADICIONE ESTA LINHA AQUI

  // üîí Esconde o bot√£o de "voltar"
  document.getElementById("btn-desselecionar").classList.add("oculto");
  
  // Oculta contorno visual
  removerContornoEdicao();
}
  
   // ================================================
// üñ±Ô∏è BOT√ÉO "‚Üê VOLTAR" ‚Äî remove sele√ß√£o da camada
// ================================================
document.getElementById("btn-desselecionar").addEventListener("click", () => {
  limparSelecaoDeCamadas();
});

  
  
  
  // üì¶ Conte√∫do textual, se for camada de texto
let conteudo = "";
if (tipo === "texto") {
  const spanTexto = camada.querySelector(".preview-texto");
  if (spanTexto) {
    conteudo = spanTexto.textContent;
  }
}

  
 
  // =================================================================
// üé® NOVO SISTEMA: Criar objeto na √°rea de edi√ß√£o (canvas)
// =================================================================
function criarObjetoCanvas(camada) {
  // üîç Garante que a camada √© v√°lida
  if (!camada || !camada.id || !camada.tipo) return;

  // üéØ Pega o container principal da √°rea de edi√ß√£o
  const container = document.getElementById("canvas-container");
  if (!container) return;

  // üß± Cria a div visual que ser√° exibida dentro do canvas
  const obj = document.createElement("div");
  obj.classList.add("objeto-edicao");   // Estilo padr√£o para todos
  obj.dataset.id = camada.id;           // Vincula o objeto √† camada

  // üéØ Posi√ß√£o inicial centralizada (ajuste simples por enquanto)
  obj.style.left = "200px";
  obj.style.top = "200px";
  obj.style.position = "absolute"; // Garante posicionamento absoluto

  // ============================
  // üì¶ Conte√∫do do objeto (por tipo)
  // ============================
  if (camada.tipo === "texto") {
    obj.textContent = camada.nome || "Texto";
    obj.style.fontSize = "20px";
    obj.style.color = "#fff";
    obj.style.fontFamily = "sans-serif";
	
    obj.style.width = "auto"; // Textos podem ter width 'auto' inicialmente
    obj.style.height = "auto";
    obj.style.padding = "5px"; // Adicione um padding para facilitar o clique/arrasto
    obj.style.whiteSpace = "nowrap"; // Evita quebra de linha inicial

  }

  else if (camada.tipo === "imagem" && camada.dados?.imagemBase64) {
    const img = new Image();
	img.src = camada.dados.imagemBase64;
	// Defina um tamanho inicial para o cont√™iner da imagem
        obj.style.width = "200px"; // Tamanho inicial da div do objeto
        obj.style.height = "200px";
        obj.style.display = "flex"; // Para centralizar a imagem dentro da div
        obj.style.justifyContent = "center";
        obj.style.alignItems = "center";

        img.style.width = "100%"; // Imagem preenche a div
        img.style.height = "100%";
        img.style.objectFit = "contain"; // Redimensiona a imagem para caber na div

	img.onload = () => {
		 // Ajusta o tamanho da div do objeto para o tamanho da imagem carregada
            // Isso evita que a div da imagem comece com 200x200px e a imagem pequena.
            // A imagem em si n√£o ter√° max-width/height, mas a div wrapper ter√° o tamanho certo.
            obj.style.width = `${img.naturalWidth}px`;
            obj.style.height = `${img.naturalHeight}px`;

            // Garante que a imagem n√£o ultrapasse um tamanho inicial grande demais
            const maxWidth = 300;
            const maxHeight = 300;
            if (obj.offsetWidth > maxWidth || obj.offsetHeight > maxHeight) {
                const ratio = Math.min(maxWidth / obj.offsetWidth, maxHeight / obj.offsetHeight);
                obj.style.width = `${obj.offsetWidth * ratio}px`;
                obj.style.height = `${obj.offsetHeight * ratio}px`;
            }
	  aplicarContornoEdicao(obj); // ‚úÖ S√≥ aplica contorno depois da imagem carregar
	};
	obj.appendChild(img);
	
	img.ondragstart = (e) => e.preventDefault();


  }

  else if (camada.tipo === "forma") {
    obj.style.width = "100px";
    obj.style.height = "100px";
    obj.style.background = "#4caf50";
    obj.style.borderRadius = "6px";
    


  }

  // üß© Adiciona ao container visual
  container.appendChild(obj);
  
  

 // üß∑ Salva refer√™ncia opcional na camada (futuro)
camada._objRef = obj;

// ‚úÖ Devolve o objeto criado
return obj;


  
}

 

}
  
// =============================================
 // üéØ Mostra contorno sobre o objeto selecionado
  // =============================================
  
function aplicarContornoEdicao(objCriado) {
  const contorno = document.getElementById("contorno-selecao");
  const canvasContainer = document.getElementById("canvas-container");

  if (!objCriado || !contorno || !canvasContainer) return;

  const margem = 8; // Espa√ßo extra em todos os lados

  // üéØ Centro do objeto
  const centerX = objCriado.offsetLeft + objCriado.offsetWidth / 2;
  const centerY = objCriado.offsetTop + objCriado.offsetHeight / 2;

  // üìê Novo tamanho do contorno
  const width = objCriado.offsetWidth + margem * 2;
  const height = objCriado.offsetHeight + margem * 2;

  // üìç Calcula nova posi√ß√£o (centralizado)
  const left = centerX - width / 2;
  const top = centerY - height / 2;

  // ‚úÖ Aplica com perfei√ß√£o sim√©trica
  contorno.style.left = `${left}px`;
  contorno.style.top = `${top}px`;
  contorno.style.width = `${width}px`;
  contorno.style.height = `${height}px`;
  contorno.classList.remove("oculto");
  
    // Obt√©m o estilo de transforma√ß√£o do objeto
    const objTransform = window.getComputedStyle(objCriado).transform;
    // Aplica a mesma transforma√ß√£o ao contorno para que ele gire junto
    contorno.style.transform = objTransform; 

    contorno.classList.remove("oculto");

  console.log("üéØ Contorno centralizado:", { left, top, width, height });
}


// ===================================
//     REMOVER CONTORNO DE EDI√á√ÉO
// ===================================
// üîπ Oculta o contorno visual de sele√ß√£o da camada atual
// üîπ Usado ao desselecionar ou clicar fora do objeto
function removerContornoEdicao() {
  const contorno = document.getElementById("contorno-selecao");
  if (contorno) {
    contorno.classList.add("oculto"); // üëÅÔ∏è Oculta visualmente
  }
}



// =======================================================================
// üñ±Ô∏è GERENCIADOR DE INTERA√á√ÉO DE OBJETOS (Arrastar, Escalonar, Rotacionar)
// =======================================================================
const ObjetoInteracaoManager = {
    objetoAtual: null,
    isArrastandoObjeto: false,
    isRedimensionando: false,
    isRotacionando: false,
    handleAtivo: null,

    startX: 0, startY: 0, // Posi√ß√£o do clique INICIAL na tela
    startWidth: 0, startHeight: 0, // Largura/Altura inicial do OBJETO
    startLeft: 0, startTop: 0, // Posi√ß√£o LEFT/TOP inicial do OBJETO
    startAngle: 0, // √Çngulo inicial para rota√ß√£o

    contorno: null,

    // Armazenar refer√™ncias das fun√ß√µes vinculadas para poder remover os listeners corretamente
    boundOnPointerDown: null,
    boundOnHandleDown: null,
    boundOnRotateDown: null,
    boundOnPointerMove: null,
    boundOnPointerUp: null,

    /**
     * Ativa a intera√ß√£o (arrastar, redimensionar, rotacionar) para um objeto espec√≠fico.
     * @param {HTMLElement} objetoAlvo O elemento HTML do objeto no canvas.
     */
    ativar: function(objetoAlvo) {
        // Desativa a intera√ß√£o do objeto anterior, se houver um ativo
        if (this.objetoAtual && this.objetoAtual !== objetoAlvo) {
            this.desativar();
        }
        this.objetoAtual = objetoAlvo;
        this.contorno = document.getElementById("contorno-selecao");

        if (!this.objetoAtual || !this.contorno) {
            console.warn("Objeto ou contorno n√£o encontrados para ativar a intera√ß√£o.");
            return;
        }

        // Armazena as refer√™ncias vinculadas das fun√ß√µes de evento
        this.boundOnPointerDown = this.onPointerDown.bind(this);
        this.boundOnHandleDown = this.onHandleDown.bind(this);
        this.boundOnRotateDown = this.onRotateDown.bind(this);
        this.boundOnPointerMove = this.onPointerMove.bind(this);
        this.boundOnPointerUp = this.onPointerUp.bind(this);

        // Adiciona listeners de eventos ao objeto principal
        this.objetoAtual.addEventListener("mousedown", this.boundOnPointerDown);
        this.objetoAtual.addEventListener("touchstart", this.boundOnPointerDown, { passive: false });

        // Adiciona listeners de eventos para as al√ßas de redimensionamento
        const handles = this.contorno.querySelectorAll(".handle-tl, .handle-tr, .handle-bl, .handle-br");
        handles.forEach(handle => {
            handle.addEventListener("mousedown", this.boundOnHandleDown);
            handle.addEventListener("touchstart", this.boundOnHandleDown, { passive: false });
        });

        // Adiciona listener de evento para a al√ßa de rota√ß√£o
        const handleRotacao = this.contorno.querySelector(".handle-rot");
        if (handleRotacao) {
            handleRotacao.addEventListener("mousedown", this.boundOnRotateDown);
            handleRotacao.addEventListener("touchstart", this.boundOnRotateDown, { passive: false });
        }
        console.log("Intera√ß√£o do objeto ATIVADA para:", objetoAlvo.dataset.id);
    },

    /**
     * Desativa a intera√ß√£o (arrastar, redimensionar, rotacionar) do objeto atual.
     */
    desativar: function() {
        if (!this.objetoAtual) return;

        // Remove os listeners do objeto principal
        this.objetoAtual.removeEventListener("mousedown", this.boundOnPointerDown);
        this.objetoAtual.removeEventListener("touchstart", this.boundOnPointerDown);

        // Remove os listeners das al√ßas
        const handles = this.contorno.querySelectorAll(".handle-tl, .handle-tr, .handle-bl, .handle-br");
        handles.forEach(handle => {
            handle.removeEventListener("mousedown", this.boundOnHandleDown);
            handle.removeEventListener("touchstart", this.boundOnHandleDown);
        });
        const handleRotacao = this.contorno.querySelector(".handle-rot");
        if (handleRotacao) {
            handleRotacao.removeEventListener("mousedown", this.boundOnRotateDown);
            handleRotacao.removeEventListener("touchstart", this.boundOnRotateDown);
        }

        // Garante que os listeners globais de movimento/fim da intera√ß√£o sejam removidos
        document.removeEventListener("mousemove", this.boundOnPointerMove);
        document.removeEventListener("mouseup", this.boundOnPointerUp);
        document.removeEventListener("touchmove", this.boundOnPointerMove);
        document.removeEventListener("touchend", this.boundOnPointerUp);

        // Reseta as refer√™ncias das fun√ß√µes vinculadas
        this.boundOnPointerDown = null;
        this.boundOnHandleDown = null;
        this.boundOnRotateDown = null;
        this.boundOnPointerMove = null;
        this.boundOnPointerUp = null;
        
        // Limpa o estado do manager
        this.objetoAtual = null;
        this.isArrastandoObjeto = false;
        this.isRedimensionando = false;
        this.isRotacionando = false;
        this.handleAtivo = null;
        this.contorno = null; // Limpa a refer√™ncia ao contorno
        MAXEditor.interacaoObjetoAtiva = false; // Sinaliza ao sistema de pan do canvas que a intera√ß√£o acabou
        console.log("Intera√ß√£o do objeto DESATIVADA.");
    },

    /**
     * Inicia o arrasto do objeto principal.
     * @param {Event} e Evento de mouse ou toque.
     */
    onPointerDown: function(e) {
        e.stopPropagation(); // Impede que o evento suba para elementos pais (como o wrapper do canvas)
        const idCamada = this.objetoAtual.dataset.id;
        const camadaElemento = document.querySelector(`.item-camada[data-id="${idCamada}"]`);
        if (camadaElemento && camadaElemento.dataset.bloqueado === "true") {
            mostrarNotificacaoAviso("Camada bloqueada! Desbloqueie para mover.");
            return;
        }
        this.isArrastandoObjeto = true;
        MAXEditor.interacaoObjetoAtiva = true; // Sinaliza ao sistema de pan do canvas que um objeto est√° sendo manipulado
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        this.startX = clientX; // Posi√ß√£o X inicial do clique do mouse/toque na TELA
        this.startY = clientY; // Posi√ß√£o Y inicial do clique do mouse/toque na TELA
        this.startLeft = parseFloat(this.objetoAtual.style.left) || 0; // Posi√ß√£o LEFT inicial do OBJETO no canvas
        this.startTop = parseFloat(this.objetoAtual.style.top) || 0;   // Posi√ß√£o TOP inicial do OBJETO no canvas

        // Adiciona listeners globais para rastrear o movimento e o fim do arrasto
        document.addEventListener("mousemove", this.boundOnPointerMove);
        document.addEventListener("mouseup", this.boundOnPointerUp);
        document.addEventListener("touchmove", this.boundOnPointerMove, { passive: false });
        document.addEventListener("touchend", this.boundOnPointerUp);
        
        this.objetoAtual.style.transition = "none"; // Desativa transi√ß√£o para movimento instant√¢neo
        this.contorno.style.transition = "none";
    },

    /**
     * Inicia o redimensionamento do objeto atrav√©s das al√ßas.
     * @param {Event} e Evento de mouse ou toque.
     */
    onHandleDown: function(e) {
        e.stopPropagation(); // Impede que o evento suba
        e.preventDefault();  // Previne sele√ß√£o de texto e outros comportamentos padr√£o
        const idCamada = this.objetoAtual.dataset.id;
        const camadaElemento = document.querySelector(`.item-camada[data-id="${idCamada}"]`);
        if (camadaElemento && camadaElemento.dataset.bloqueado === "true") {
            mostrarNotificacaoAviso("Camada bloqueada! Desbloqueie para redimensionar.");
            return;
        }
        this.isRedimensionando = true;
        MAXEditor.interacaoObjetoAtiva = true; // Sinaliza
        this.handleAtivo = e.target.className.split(' ').find(cls => cls.startsWith('handle-')); // Identifica qual al√ßa foi clicada
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        this.startX = clientX;
        this.startY = clientY;
        this.startWidth = this.objetoAtual.offsetWidth;
        this.startHeight = this.objetoAtual.offsetHeight;
        this.startLeft = parseFloat(this.objetoAtual.style.left) || 0;
        this.startTop = parseFloat(this.objetoAtual.style.top) || 0;

        document.addEventListener("mousemove", this.boundOnPointerMove);
        document.addEventListener("mouseup", this.boundOnPointerUp);
        document.addEventListener("touchmove", this.boundOnPointerMove, { passive: false });
        document.addEventListener("touchend", this.boundOnPointerUp);

        this.objetoAtual.style.transition = "none";
        this.contorno.style.transition = "none";
    },

    /**
     * Inicia a rota√ß√£o do objeto atrav√©s da al√ßa de rota√ß√£o.
     * @param {Event} e Evento de mouse ou toque.
     */
    onRotateDown: function(e) {
        e.stopPropagation();
        e.preventDefault();
        const idCamada = this.objetoAtual.dataset.id;
        const camadaElemento = document.querySelector(`.item-camada[data-id="${idCamada}"]`);
        if (camadaElemento && camadaElemento.dataset.bloqueado === "true") {
            mostrarNotificacaoAviso("Camada bloqueada! Desbloqueie para rotacionar.");
            return;
        }
        this.isRotacionando = true;
        MAXEditor.interacaoObjetoAtiva = true; // Sinaliza
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        const objRect = this.objetoAtual.getBoundingClientRect();
        const objCenterX = objRect.left + objRect.width / 2;
        const objCenterY = objRect.top + objRect.height / 2;

        // Calcula o √¢ngulo inicial do ponteiro em rela√ß√£o ao centro do objeto
        this.startAngle = Math.atan2(clientY - objCenterY, clientX - objCenterX) * (180 / Math.PI);
        
        // Pega o √¢ngulo de rota√ß√£o atual do objeto para somar (se j√° houver rota√ß√£o)
        const currentTransform = window.getComputedStyle(this.objetoAtual).transform;
        const match = currentTransform.match(/rotate\(([^deg]+)deg\)/);
        if (match) {
            this.startAngle -= parseFloat(match[1]);
        }

        document.addEventListener("mousemove", this.boundOnPointerMove);
        document.addEventListener("mouseup", this.boundOnPointerUp);
        document.addEventListener("touchmove", this.boundOnPointerMove, { passive: false });
        document.addEventListener("touchend", this.boundOnPointerUp);

        this.objetoAtual.style.transition = "none";
        this.contorno.style.transition = "none";
    },

    /**
     * Lida com o movimento do ponteiro (mouse ou toque) para arrastar, redimensionar ou rotacionar.
     * @param {Event} e Evento de mouse ou toque.
     */
    onPointerMove: function(e) {
        // Se nenhuma das flags de intera√ß√£o est√° ativa, n√£o faz nada
        if (!this.isArrastandoObjeto && !this.isRedimensionando && !this.isRotacionando) return;
        e.preventDefault(); // Previne o comportamento padr√£o (ex: rolagem da p√°gina)

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Usa o zoom atual do MAXEditor para ajustar os movimentos/redimensionamentos
        const currentScale = MAXEditor.zoom;

        if (this.isArrastandoObjeto) {
            // As mudan√ßas (dx, dy) devem ser baseadas na diferen√ßa entre a posi√ß√£o
            // atual do mouse e a posi√ß√£o inicial do clique, ajustada pela escala.
            const dx = (clientX - this.startX) / currentScale; 
            const dy = (clientY - this.startY) / currentScale; 
            
            this.objetoAtual.style.left = `${this.startLeft + dx}px`;
            this.objetoAtual.style.top = `${this.startTop + dy}px`;
        } 
        else if (this.isRedimensionando) {
            let newWidth = this.startWidth;
            let newHeight = this.startHeight;
            let newLeft = this.startLeft;
            let newTop = this.startTop;

            const dx = (clientX - this.startX) / currentScale;
            const dy = (clientY - this.startY) / currentScale;

            switch (this.handleAtivo) {
                case 'handle-br': // Bottom Right
                    newWidth = Math.max(20, this.startWidth + dx);
                    newHeight = Math.max(20, this.startHeight + dy);
                    break;
                case 'handle-bl': // Bottom Left
                    newWidth = Math.max(20, this.startWidth - dx);
                    newHeight = Math.max(20, this.startHeight + dy);
                    newLeft = this.startLeft + dx;
                    break;
                case 'handle-tr': // Top Right
                    newWidth = Math.max(20, this.startWidth + dx);
                    newHeight = Math.max(20, this.startHeight - dy);
                    newTop = this.startTop + dy;
                    break;
                case 'handle-tl': // Top Left
                    newWidth = Math.max(20, this.startWidth - dx);
                    newHeight = Math.max(20, this.startHeight - dy);
                    newLeft = this.startLeft + dx;
                    newTop = this.startTop + dy;
                    break;
            }

            this.objetoAtual.style.width = `${newWidth}px`;
            this.objetoAtual.style.height = `${newHeight}px`;
            this.objetoAtual.style.left = `${newLeft}px`;
            this.objetoAtual.style.top = `${newTop}px`;

            // Para imagens, redimensiona a imagem interna tamb√©m para preencher o container
            if (this.objetoAtual.dataset.tipo === "imagem") {
                const img = this.objetoAtual.querySelector("img");
                if (img) {
                    img.style.width = "100%";
                    img.style.height = "100%";
                    img.style.maxWidth = "none";
                    img.style.maxHeight = "none";
                }
            }
        }
        else if (this.isRotacionando) {
            const objRect = this.objetoAtual.getBoundingClientRect();
            // Calcular o centro do objeto em rela√ß√£o √† tela vis√≠vel
            const objCenterX = objRect.left + objRect.width / 2;
            const objCenterY = objRect.top + objRect.height / 2;

            // Calcular o √¢ngulo do ponteiro em rela√ß√£o ao centro do objeto
            const currentPointerAngle = Math.atan2(clientY - objCenterY, clientX - objCenterX) * (180 / Math.PI);
            // Calcular o novo √¢ngulo de rota√ß√£o (ajustado pelo √¢ngulo inicial do clique)
            const newAngle = currentPointerAngle - this.startAngle;
            
            // Arredonda para evitar n√∫meros flutuantes muito longos
            const finalAngle = Math.round(newAngle * 100) / 100;

            // Preserva outras transforma√ß√µes (se houver) e aplica a nova rota√ß√£o
            const currentTransform = this.objetoAtual.style.transform;
            // Regex para encontrar e remover rota√ß√µes existentes, deixando outras transforms
            let updatedTransform = currentTransform.replace(/rotate\(([^deg]+)deg\)/, '').trim();
            this.objetoAtual.style.transform = `${updatedTransform} rotate(${finalAngle}deg)`.trim();
        }

        // Atualiza o contorno para seguir o objeto ap√≥s qualquer transforma√ß√£o
        aplicarContornoEdicao(this.objetoAtual);
    },

    /**
     * Finaliza qualquer intera√ß√£o (arrastar, redimensionar, rotacionar).
     */
    onPointerUp: function() {
        this.isArrastandoObjeto = false;
        this.isRedimensionando = false;
        this.isRotacionando = false;
        this.handleAtivo = null;
        MAXEditor.interacaoObjetoAtiva = false; // Sinaliza que nenhuma intera√ß√£o de objeto est√° ativa

        // Restaura transi√ß√µes CSS para suavidade
        this.objetoAtual.style.transition = "";
        this.contorno.style.transition = "";

        // Remove os listeners globais usando as refer√™ncias armazenadas
        document.removeEventListener("mousemove", this.boundOnPointerMove);
        document.removeEventListener("mouseup", this.boundOnPointerUp);
        document.removeEventListener("touchmove", this.boundOnPointerMove);
        document.removeEventListener("touchend", this.boundOnPointerUp);
    }
};


// ===================================
// üßº Limpa a intera√ß√£o ativa de objetos
// ===================================
function finalizarInteracaoObjetoAnterior() {
    // Isso √© um pouco mais avan√ßado, requer controle sobre qual objeto est√° ativo
    // Idealmente, onPointerUp j√° lida com o que √© necess√°rio.
    // Mas, se estamos TROCANDO de objeto, o 'mouseup' do objeto anterior pode n√£o ter ocorrido.

    // A maneira mais simples √© ter uma refer√™ncia ao objeto ANTERIORMENTE ativo
    // e remover os listeners dele ou for√ßar um "onPointerUp" para ele.

    // Por enquanto, a solu√ß√£o de stopPropagation e preventDefault no 'mousedown' do wrapper
    // √â a mais direta. Se o problema persistir AP√ìS o padding, vamos investigar mais a fundo
    // o fluxo de eventos e se algum listener est√° "vazando".
}



  
  
  
 //////////////[ CAMADAS ]/////////////// 
 ///////////////[ FINAL ]////////////////
  
  
  
  // Habilita rolagem horizontal com arrasto do mouse nos botoes da parte de baixo de ferramentas 
  
const scrollArea = document.getElementById('ferramentas-scroll');
let isDown = false;
let startX, scrollLeft;

scrollArea.addEventListener('mousedown', (e) => {
  isDown = true;
  scrollArea.classList.add('ativo');
  startX = e.pageX - scrollArea.offsetLeft;
  scrollLeft = scrollArea.scrollLeft;
});

scrollArea.addEventListener('mouseleave', () => {
  isDown = false;
});

scrollArea.addEventListener('mouseup', () => {
  isDown = false;
});

scrollArea.addEventListener('mousemove', (e) => {
  if (!isDown) return;
  e.preventDefault();
  const x = e.pageX - scrollArea.offsetLeft;
  const walk = (x - startX) * 1.5; // Velocidade do arrasto
  scrollArea.scrollLeft = scrollLeft - walk;
});

  
  
  
  
     iniciarSistemaDeZoom()

  
});
